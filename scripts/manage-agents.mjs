import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");

const lines = (...entries) => entries.join("\n");

const rootAgent = lines(
  "# Operational Agent Charter",
  "",
  "> This charter is regenerated by `scripts/manage-agents.mjs`. Run `npm run agent:sync` at the beginning and end of every session so the manifest stays authoritative.",
  "",
  "## Execution Contract",
  "- The repository is an Expo 53 / React Native 0.79 app that powers the React T3TR15 arcade experience. Every contribution must enhance the fast-paced Tetris gameplay loop while keeping the build production-ready.",
  "- No placeholders, stubs, mocks, or half-implemented features are ever permitted. Ship complete, functional code with thoughtful error handling and polish.",
  "- Always understand the impacted modules before editing: inspect gameplay state, reward logic, onboarding flows, and navigation scaffolding so updates remain cohesive.",
  "",
  "## Required Workflow",
  "1. Install dependencies with `npm install` (or `bun install` if you intentionally opt into Bun).",
  "2. Synchronize agent files via `npm run agent:sync`. Commit both source and regenerated AGENTS documents together.",
  "3. Implement changes using strongly typed TypeScript, platform-aware React Native patterns, and the shared utilities already in the project (Zustand stores, design system tokens, SFX helpers, etc.).",
  "4. Format code with `npx prettier --write .` and lint via `npm run lint`; fix every warning.",
  "5. Run `npm run typecheck` and `npm test` for every substantive change. Execute Detox flows when altering navigation or onboarding (build then run the matching `npm run detox:*` commands). Document any failures.",
  "6. Update documentation (including this charter or nested AGENTS files) whenever behaviour, UX copy, or architecture shifts.",
  "",
  "## Architecture Overview",
  "- **State Management:** Zustand stores in `src/state` coordinate onboarding, Tetris gameplay loops, rewards, and notification preferences. Stores use AsyncStorage-backed persistence—extend them with immutable updates and mirrored unit tests in `__tests__`.",
  "- **Main Loop:** `src/mainLoop/useMainLoop.ts` hooks into the React Native AppState to begin and end play sessions automatically. Any gameplay change that affects cadence must stay compatible with this hook.",
  "- **Design System:** Shared primitives live in `src/design-system` with tokens, animation helpers, and component wrappers built around NativeWind/Tailwind. New UI must consume these tokens and respect theming.",
  "- **Navigation:** Multi-stack navigation is implemented under `src/navigation` using React Navigation 7. Follow established navigator patterns, extend typed param lists, and keep linking/deep-link definitions synchronized.",
  "- **Gameplay Rendering:** `src/screens/TetrisScreen.tsx` centralises gesture handling, haptics, and FX; coordinate with `src/components/MatrixRain.tsx` and `src/components/SlashTrail.tsx` when altering visuals.",
  "- **Utilities:** Centralised helpers (logging, retry semantics, ASCII rendering, SFX) exist in `src/utils`. Reuse them rather than reimplementing behaviour.",
  "",
  "## Implementation Directives",
  "- Prefer functional, composable React components with hooks split into dedicated modules (see `src/mainLoop/useMainLoop.ts`). Memoize heavy computations and respect React Native performance constraints.",
  "- Keep gameplay responsive: avoid blocking renders, batch store updates, and ensure animations run at 60 fps on mid-tier hardware.",
  "- Persisted data must remain backward compatible. Migrate Zustand schemas carefully and provide default migrations inside store initialisation when shapes change.",
  "",
  "## Documentation & Knowledge Management",
  "- Keep `docs/` synchronized with the shipped Tetris experience (game design notes, scoring tables, UX rationale). Update `docs/roadmap.md` whenever priorities shift so planning reflects the live backlog.",
  "- When introducing new subsystems, extend the AGENTS manifest so future contributors inherit the right context.",
  "",
  "## Agent Governance",
  "- This repository treats AGENTS files as canonical contributor guidance. The manifest in `scripts/manage-agents.mjs` defines every sanctioned AGENTS file. Running `npm run agent:sync` will create, update, or delete AGENTS files to match the manifest—never edit generated files without updating the manifest.",
  "- If you create a new directory that requires bespoke guidance, extend the manifest with a new entry, document its scope, and re-run the sync command.",
  "- Do not leave obsolete AGENTS files in the tree—the sync command will remove anything not declared in the manifest.",
  "",
  "Stay rigorous, document intent, and ensure every change keeps React T3TR15 feeling like the definitive retro Tetris homage.",
);

const srcAgent = lines(
  "# src Implementation Guide",
  "",
  "Scope: applies to all source files under `src/`, except where more specific nested AGENTS files override these rules.",
  "",
  "## Patterns & Styling",
  "- Author components and utilities in TypeScript with explicit types—lean on inference but avoid `any`.",
  "- Use NativeWind tailwind classes and the design system tokens for styling. Refrain from inline magic numbers unless grounded in tokens or well-documented calculations.",
  "- Co-locate unit tests within `__tests__` directories. Use Jest with React Testing Library or React Native Testing Library helpers as appropriate.",
  "",
  "## React & Navigation",
  "- Prefer functional components with hooks. When side effects are needed, wrap them in `useEffect` with well-defined dependency arrays and cancellation guards.",
  "- Extend navigation types in `src/navigation` when introducing screens. Keep deep-link definitions synchronized across platforms.",
  "",
  "## State & Utilities",
  "- Access Zustand stores via exported selectors instead of reading the entire store in components. Derive memoized slices to avoid excessive renders.",
  "- Shared utilities in `src/utils` should stay generic and well-tested—avoid scattering bespoke helpers across screens.",
  "",
  "## Testing",
  "- Write Jest tests for logic-heavy modules and Detox scenarios when UI flows change. Mirror coverage expectations already established in sibling files.",
  "- Maintain consistent accessibility identifiers so automated tests can target key UI affordances (e.g., onboarding CTAs, pause buttons).",
);

const srcStateAgent = lines(
  "# src/state Store Charter",
  "",
  "Scope: Zustand stores, engines, and supporting data under `src/state`.",
  "",
  "- Maintain immutable state updates; avoid mutating nested objects directly. Use spread syntax or helper utilities to clone state fragments before modification.",
  "- Extend store types precisely. Update `AppStore`, `TetrisStore`, and other exports with exhaustive discriminated unions instead of loose objects.",
  "- Persisted state must include migration paths when structure changes. Introduce versioned persistence or ad-hoc migrations directly in the persistence middleware.",
  "- Every new action or computed helper needs associated Jest coverage in `src/state/__tests__/`. Tests should cover hydration behaviour, persistence, and side effects like reward unlocks or streak tracking.",
);

const docsAgent = lines(
  "# docs Authorship Guide",
  "",
  "Scope: documentation under `docs/` (game design briefs, scoring notes, UX research).",
  "",
  "- Keep documents up to date with the implemented Tetris experience. Whenever mechanics, UI flows, or scoring models change, update the matching markdown source in the same pull request.",
  "- Use descriptive section headings, tables, and bullet lists—avoid placeholder text. Include diagrams or ASCII tables when they clarify gameplay.",
  "- Cross-reference app modules using fully-qualified paths (e.g., `src/state/tetrisStore.ts`) so engineers can trace requirements to code.",
  "- Maintain the roadmap in `docs/roadmap.md` alongside feature work; retire completed items and document new initiatives as they enter development.",
  "- Prefer American English spelling, wrap lines at ~120 characters, and use fenced code blocks for commands or configuration snippets.",
);

const scriptsAgent = lines(
  "# scripts Maintenance Guide",
  "",
  "Scope: automation, tooling, and helper scripts in `scripts/`.",
  "",
  "- Write Node scripts using modern ES modules. Prefer async/await with explicit error surfaces and exit codes.",
  "- Provide idempotent behaviour—rerunning a script should not produce divergent outcomes (e.g., `manage-agents.mjs` writes files only when content changes).",
  "- Document usage in script headers or README updates, and expose npm script aliases (see `package.json`).",
  "- Log actionable messages via `console.info`/`console.error` so CI and developers understand the outcome.",
  "- Use `node scripts/manage-agents.mjs --check` (surfaced via `npm run agent:check`) to verify manifest coverage without mutating the repo.",
  "- Keep the AGENTS manifest authoritative: `npm run agent:sync` will prune unmanaged AGENTS files in addition to creating and updating managed ones.",
);

const srcComponentsAgent = lines(
  "# src/components Design Guide",
  "",
  "Scope: shared UI components under `src/components` and nested directories.",
  "",
  "- Compose UI primitives using design-system components (buttons, typography, modal shells) before introducing bespoke styles.",
  "- Ensure every component is platform-aware: guard iOS/Android specific code with `Platform.OS` checks and provide fallbacks for web.",
  "- Prefer controlled props over implicit state. When internal state is required, expose callbacks so consuming screens can persist data.",
  "- Add visual regression coverage via storybook snippets or screenshot tests when modifying reusable UI (coordinate with Detox where applicable).",
  "- Export a single public interface per file. Group supporting helpers within the same module but do not leak them from index barrels unless necessary.",
);

const manifest = [
  { relativePath: "AGENTS.md", content: rootAgent },
  { relativePath: path.join("docs", "AGENTS.md"), content: docsAgent },
  { relativePath: path.join("scripts", "AGENTS.md"), content: scriptsAgent },
  { relativePath: path.join("src", "AGENTS.md"), content: srcAgent },
  { relativePath: path.join("src", "components", "AGENTS.md"), content: srcComponentsAgent },
  { relativePath: path.join("src", "state", "AGENTS.md"), content: srcStateAgent },
];

const ignoredDirs = new Set(["node_modules", ".git", "android", "ios", ".expo", ".turbo", "build", "dist"]);

async function ensureDirectory(filePath) {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
}

function parseFlags(argv) {
  const supported = new Map([["--check", "Run without writing and fail if updates would occur."]]);
  const flags = {
    check: false,
  };

  for (const arg of argv) {
    if (!supported.has(arg)) {
      const recognised = Array.from(supported.keys()).join(", ") || "<none>";
      throw new Error(
        lines(
          `Unknown flag: ${arg}`,
          recognised === "<none>" ? "This script does not accept additional flags." : `Supported flags: ${recognised}`,
        ),
      );
    }

    if (arg === "--check") {
      flags.check = true;
    }
  }

  return flags;
}

async function ensureFileContent(filePath, content, { checkOnly }) {
  let existingContent = null;
  let exists = true;
  try {
    existingContent = await fs.readFile(filePath, "utf8");
  } catch (error) {
    if (error.code === "ENOENT") {
      exists = false;
    } else {
      throw error;
    }
  }

  const normalised = `${content}\n`;
  if (exists && existingContent === normalised) {
    return { changed: false };
  }

  if (checkOnly) {
    return { changed: true, reason: exists ? "outdated" : "missing" };
  }

  await ensureDirectory(filePath);
  await fs.writeFile(filePath, normalised, "utf8");

  return { changed: true, reason: exists ? "updated" : "created" };
}

async function collectAgentFiles(dir, results) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (ignoredDirs.has(entry.name)) {
      continue;
    }

    const absolutePath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      await collectAgentFiles(absolutePath, results);
    } else if (entry.isFile() && entry.name === "AGENTS.md") {
      results.add(path.resolve(absolutePath));
    }
  }
}

function normaliseForSort(relativePath) {
  return relativePath.split(path.sep).join("/");
}

async function removeFileAndCleanup(filePath) {
  await fs.unlink(filePath);

  let currentDir = path.dirname(filePath);
  while (currentDir.startsWith(repoRoot) && currentDir !== repoRoot) {
    let entries;
    try {
      entries = await fs.readdir(currentDir);
    } catch (error) {
      if (error.code === "ENOENT") {
        currentDir = path.dirname(currentDir);
        continue;
      }

      throw error;
    }

    if (entries.length > 0) {
      break;
    }

    try {
      await fs.rmdir(currentDir);
    } catch (error) {
      if (error.code === "ENOTEMPTY") {
        break;
      }

      if (error.code !== "ENOENT") {
        throw error;
      }
    }

    currentDir = path.dirname(currentDir);
  }
}

async function main() {
  const flags = parseFlags(process.argv.slice(2));
  const checkOnly = flags.check;
  const expected = new Map();
  const duplicatePaths = new Set();
  const relativePaths = [];

  for (const item of manifest) {
    const absolutePath = path.resolve(repoRoot, item.relativePath);
    if (expected.has(absolutePath)) {
      duplicatePaths.add(path.relative(repoRoot, absolutePath));
    } else {
      expected.set(absolutePath, item.content);
    }
    relativePaths.push(normaliseForSort(item.relativePath));
  }

  if (duplicatePaths.size > 0) {
    const duplicateMessage = lines(
      "Manifest contains duplicate AGENTS targets:",
      ...Array.from(duplicatePaths)
        .sort((a, b) => a.localeCompare(b))
        .map((relativePath) => `- ${relativePath}`),
      "",
      "Deduplicate the manifest entries before rerunning the sync.",
    );
    throw new Error(duplicateMessage);
  }

  const sortedPaths = [...relativePaths].sort((a, b) => a.localeCompare(b));
  for (let index = 0; index < relativePaths.length; index += 1) {
    if (relativePaths[index] !== sortedPaths[index]) {
      const message = lines(
        "Manifest entries must be sorted lexicographically by relative path.",
        "Current order:",
        ...relativePaths.map((value) => `- ${value}`),
        "",
        "Expected order:",
        ...sortedPaths.map((value) => `- ${value}`),
      );
      throw new Error(message);
    }
  }

  let changed = false;
  const mismatches = [];
  for (const [filePath, content] of expected.entries()) {
    const result = await ensureFileContent(filePath, content, { checkOnly });
    if (!result.changed) {
      continue;
    }

    if (checkOnly) {
      mismatches.push({ filePath, reason: result.reason });
    } else {
      const relativePath = path.relative(repoRoot, filePath);
      const verb = result.reason === "created" ? "Created" : "Updated";
      console.info(`${verb} ${relativePath}`);
      changed = true;
    }
  }

  const discovered = new Set();
  await collectAgentFiles(repoRoot, discovered);

  const unexpected = [];
  for (const filePath of discovered) {
    if (!expected.has(filePath)) {
      unexpected.push(filePath);
    }
  }

  if (unexpected.length > 0) {
    const sortedUnexpected = unexpected
      .map((filePath) => path.relative(repoRoot, filePath))
      .sort((a, b) => a.localeCompare(b));

    if (checkOnly) {
      const message = lines(
        "Detected AGENTS files without manifest entries:",
        ...sortedUnexpected.map((relativePath) => `- ${relativePath}`),
        "",
        "Update the manifest in scripts/manage-agents.mjs to cover these scoped directories or remove the files.",
      );
      throw new Error(message);
    }

    for (const relativePath of sortedUnexpected) {
      const absolutePath = path.resolve(repoRoot, relativePath);
      await removeFileAndCleanup(absolutePath);
      console.info(`Removed ${relativePath}`);
      changed = true;
    }
  }

  if (checkOnly) {
    if (mismatches.length > 0) {
      const message = lines(
        "AGENTS manifest is out of sync. Run `npm run agent:sync` to regenerate:",
        ...mismatches
          .map(({ filePath, reason }) => {
            const relativePath = path.relative(repoRoot, filePath);
            const suffix = reason === "missing" ? "(missing)" : "(outdated)";
            return `- ${relativePath} ${suffix}`;
          })
          .sort((a, b) => a.localeCompare(b)),
      );
      throw new Error(message);
    }

    console.info("AGENTS manifest is in sync.");
    return;
  }

  if (!changed) {
    console.info("AGENTS manifest already in sync.");
  }
}

main().catch((error) => {
  console.error("Failed to sync AGENTS manifest", error);
  process.exitCode = 1;
});
