import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const repoRoot = path.resolve(__dirname, "..");

const lines = (...entries) => entries.join("\n");

const rootAgent = lines(
  "# Operational Agent Charter",
  "",
  "> This charter is regenerated by `scripts/manage-agents.mjs`. Run `npm run agent:sync` at the beginning and end of every session so the manifest stays authoritative.",
  "",
  "## Execution Contract",
  "- The repository is an Expo 53 / React Native 0.79 app that powers an advanced network diagnostics and security research assistant. Every contribution must be production-ready and align with security research ethics.",
  "- No placeholders, stubs, mocks, simplified snippets, or partially implemented logic are ever permitted. Ship complete, fully working features with exhaustive error handling.",
  "- Always understand the impacted modules before editing: inspect existing implementations, analytics hooks, and persistence flows so that updates remain consistent with the holistic architecture.",
  "",
  "## Required Workflow",
  "1. Install dependencies with `npm install` (or `bun install` if you intentionally opt into Bun).",
  "2. Synchronize agent files via `npm run agent:sync`. Commit both source and regenerated AGENTS documents together.",
  "3. Implement changes using strongly typed TypeScript, platform-specific React Native patterns, and repository utilities (zustand stores, NativeWind, analytics tracking, etc.).",
  "4. Format code with `npx prettier --write .` and lint via `npm run lint`; fix every warning.",
  "5. Run `npm run typecheck`, `npm test`, and any relevant Detox end-to-end flows (`npm run detox:build:*` then `npm run test:e2e:*`) when changes touch runtime behaviour. Capture and document failures instead of ignoring them.",
  "6. Update documentation (including this charter or nested AGENTS files) whenever behaviour, APIs, or architecture shift.",
  "",
  "## Architecture Overview",
  "- **State Management:** Zustand stores in `src/state` coordinate onboarding, Tetris gameplay loops, rewards, feature flags, and persistent analytics toggles. Stores use AsyncStorage-backed persistence and emit retention events—extend them with immutable updates and mirrored unit tests in `__tests__`.",
  "- **Design System:** Shared primitives live in `src/design-system` with tokens, animation helpers, and component wrappers built around NativeWind and Tailwind tokens. New UI must consume tokens and respect the theming contract exposed through `tokens.ts`.",
  "- **Navigation:** Multi-stack navigation is implemented under `src/navigation` using React Navigation 7. Follow established navigator patterns, extend typed param lists, and update linking configs when screens move.",
  "- **Services & Monitoring:** Network diagnostics, analytics, and notification orchestration live in `src/services`, `src/analytics`, and `src/monitoring`. Use platform-appropriate public APIs (CoreWLAN/NetworkExtension on iOS, WifiManager/VpnService on Android) with graceful degradation when unavailable.",
  "- **Utilities:** Centralised helpers (logging, retry semantics, ASCII rendering, SFX) exist in `src/utils`. Reuse them rather than reimplementing behaviour.",
  "",
  "## Implementation Directives",
  "- Prefer functional, composable React components with hooks split into dedicated modules (see `src/utils/useApiRequest.ts`). Memoize heavy computations and respect React Native performance constraints.",
  "- Capture analytics through `src/analytics/analyticsClient.ts` and log operational data using `src/utils/logger.ts`. Every network diagnostic feature should emit structured retention events.",
  "- When adding native functionality, wire TurboModules / Native Modules via `src/services/network/nativeModule.ts`, providing fallbacks and TypeScript-safe facades. Include integration notes for Xcode (entitlements, NetworkExtension permissions) and Android manifests where applicable.",
  "- Persisted data must remain backward compatible. Migrate Zustand schemas carefully and provide default migrations inside store initialisation.",
  "",
  "## Documentation & Knowledge Management",
  "- Keep `docs/` synchronized with feature work (design decisions, market analysis, onboarding research). Record new instrumentation or UX changes in the appropriate document and link from PR descriptions when relevant.",
  "- When introducing new sub-domains, add dedicated AGENTS guides by updating `scripts/manage-agents.mjs` so future contributors inherit precise context.",
  "",
  "## Agent Governance",
  "- This repository treats AGENTS files as canonical contributor guidance. The manifest in `scripts/manage-agents.mjs` defines every sanctioned AGENTS file. Running `npm run agent:sync` will create, update, or delete AGENTS files to match the manifest—never edit generated files without updating the manifest.",
  "- If you create a new directory that requires bespoke guidance, extend the manifest with a new entry, document its scope, and re-run the sync command.",
  "- Do not leave obsolete AGENTS files in the tree—the sync command will remove anything not declared in the manifest.",
  "",
  "Stay rigorous, document intent, and ensure every change elevates the production readiness of this network diagnostics platform."
);

const srcAgent = lines(
  "# src Implementation Guide",
  "",
  "Scope: applies to all source files under `src/`, except where more specific nested AGENTS files override these rules.",
  "",
  "## Patterns & Styling",
  "- Author components and utilities in TypeScript with explicit types—enable strict inference rather than relying on `any`.",
  "- Lean on NativeWind tailwind classes and the design system tokens for styling consistency. Refrain from inline magic numbers unless grounded in tokens or documented calculations.",
  "- Co-locate unit tests within `__tests__` directories. Use Jest with React Testing Library or node test utilities as appropriate.",
  "",
  "## React & Navigation",
  "- Prefer functional components with hooks. When side effects are needed, wrap them in `useEffect` with well-defined dependency arrays and cancellation guards.",
  "- Extend navigation types in `src/navigation` when introducing screens. Keep deep-linking definitions synchronized across platforms.",
  "",
  "## State & Services",
  "- Access Zustand stores via exported selectors instead of reading the entire store in components. Derive memoized slices to avoid excessive renders.",
  "- Service modules under `src/services` should expose typed async APIs with comprehensive error handling and logging through `logger.ts`.",
  "",
  "## Testing & Instrumentation",
  "- Write Jest tests for logic-heavy modules and Detox scenarios when UI flows change. Mirror coverage expectations already established in sibling files.",
  "- Emit analytics events and monitoring signals consistently—when adding new flows, update analytics schemas and ensure opt-in/opt-out respect persists."
);

const srcStateAgent = lines(
  "# src/state Store Charter",
  "",
  "Scope: Zustand stores, engines, and supporting data under `src/state`.",
  "",
  "- Maintain immutable state updates; avoid mutating nested objects directly. Use spread syntax or helper utilities to clone state fragments before modification.",
  "- Extend store types precisely. Update `AppStore`, `TetrisStore`, and other exports with exhaustive discriminated unions instead of loose objects.",
  "- Persisted state must include migration paths when structure changes. Introduce versioned persistence or ad-hoc migrations directly in the persistence middleware.",
  "- Every new action or computed helper needs associated Jest coverage in `src/state/__tests__/`. Tests should cover hydration behaviour, persistence, and side effects like analytics tracking.",
  "- Respect feature flags from `featureFlagsStore.ts` and ensure new behaviour remains guardable for staged rollouts."
);

const docsAgent = lines(
  "# docs Authorship Guide",
  "",
  "Scope: documentation under `docs/` (product briefs, design artefacts, network setup guides).",
  "",
  "- Keep documents up to date with the implemented product. Whenever logic, flows, or research inputs change, update the matching markdown source in the same pull request.",
  "- Use descriptive section headings, tables, and bullet lists—avoid placeholder text. Include architecture diagrams or sequence descriptions when relevant.",
  "- Cross-reference app modules using fully-qualified paths (e.g., `src/services/network/index.ts`) so engineers can trace requirements to code.",
  "- Prefer American English spelling, wrap lines at ~120 characters, and use fenced code blocks for commands or configuration snippets.",
  "- When adding new documentation subfolders, register an AGENTS entry in the manifest if specialised rules apply."
);

const scriptsAgent = lines(
  "# scripts Maintenance Guide",
  "",
  "Scope: automation, tooling, and helper scripts in `scripts/`.",
  "",
  "- Write Node scripts using modern ES modules. Prefer async/await with explicit error surfaces and exit codes.",
  "- Provide idempotent behaviour—rerunning a script should not produce divergent outcomes (e.g., `manage-agents.mjs` writes files only when content changes).",
  "- Document usage in script headers or README updates, and expose npm script aliases (see `package.json`).",
  "- Log actionable messages via `console.info`/`console.error` so CI and developers understand the outcome."
);

const srcComponentsAgent = lines(
  "# src/components Design Guide",
  "",
  "Scope: shared UI components under `src/components` and nested directories.",
  "",
  "- Compose UI primitives using design-system components (buttons, typography, modal shells) before introducing bespoke styles.",
  "- Ensure every component is platform-aware: guard iOS/Android specific code with `Platform.OS` checks and provide fallbacks for web.",
  "- Prefer controlled props over implicit state. When internal state is required, expose callbacks so consuming screens can persist data or analytics.",
  "- Add visual regression coverage via storybook snippets or screenshot tests when modifying reusable UI (coordinate with Detox where applicable).",
  "- Export a single public interface per file. Group supporting helpers within the same module but do not leak them from index barrels unless necessary."
);

const srcServicesAgent = lines(
  "# src/services Implementation Guide",
  "",
  "Scope: service abstractions, network diagnostics facades, and configuration modules in `src/services`.",
  "",
  "- Encapsulate platform-specific behaviour within dedicated adapters (see `network/nativeModule.ts`). Provide clear TypeScript interfaces in `types.ts` files and expose a single entry point through `index.ts`.",
  "- Validate inputs rigorously and surface domain-specific errors using helpers from `src/utils/errors.ts`. Do not throw raw errors without context.",
  "- Integrate logging via `logger.ts` and analytics events so diagnostics remain observable.",
  "- Unit test service logic using Jest, mocking native bridges responsibly while still asserting that fallbacks work when permissions or hardware are unavailable."
);

const manifest = [
  { relativePath: "AGENTS.md", content: rootAgent },
  { relativePath: path.join("src", "AGENTS.md"), content: srcAgent },
  { relativePath: path.join("src", "state", "AGENTS.md"), content: srcStateAgent },
  { relativePath: path.join("src", "components", "AGENTS.md"), content: srcComponentsAgent },
  { relativePath: path.join("src", "services", "AGENTS.md"), content: srcServicesAgent },
  { relativePath: path.join("docs", "AGENTS.md"), content: docsAgent },
  { relativePath: path.join("scripts", "AGENTS.md"), content: scriptsAgent },
];

const ignoredDirs = new Set([
  "node_modules",
  ".git",
  "android",
  "ios",
  ".expo",
  ".turbo",
  "build",
  "dist",
]);

async function ensureDirectory(filePath) {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
}

async function writeFileIfChanged(filePath, content) {
  let existing = null;
  try {
    existing = await fs.readFile(filePath, "utf8");
  } catch (error) {
    if (error.code !== "ENOENT") {
      throw error;
    }
  }

  const normalised = `${content}\n`;
  if (existing === normalised) {
    return false;
  }

  await ensureDirectory(filePath);
  await fs.writeFile(filePath, normalised, "utf8");
  return true;
}

async function collectAgentFiles(dir, results) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  for (const entry of entries) {
    if (ignoredDirs.has(entry.name)) {
      continue;
    }

    const absolutePath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      await collectAgentFiles(absolutePath, results);
    } else if (entry.isFile() && entry.name === "AGENTS.md") {
      results.add(path.resolve(absolutePath));
    }
  }
}

async function main() {
  const expected = new Map();
  for (const item of manifest) {
    const absolutePath = path.resolve(repoRoot, item.relativePath);
    expected.set(absolutePath, item.content);
  }

  const updates = [];
  for (const [filePath, content] of expected.entries()) {
    const changed = await writeFileIfChanged(filePath, content);
    if (changed) {
      updates.push({ type: "write", filePath });
    }
  }

  const discovered = new Set();
  await collectAgentFiles(repoRoot, discovered);
  for (const filePath of discovered) {
    if (!expected.has(filePath)) {
      await fs.unlink(filePath);
      updates.push({ type: "delete", filePath });
    }
  }

  if (updates.length === 0) {
    console.info("AGENTS manifest already in sync.");
    return;
  }

  for (const { type, filePath } of updates) {
    const relative = path.relative(repoRoot, filePath);
    console.info(`${type === "write" ? "Updated" : "Removed"}: ${relative}`);
  }
}

main().catch((error) => {
  console.error("Failed to synchronise AGENTS files:", error);
  process.exitCode = 1;
});
